import java.util.Scanner;

class Graph{
    private int V;           //노드의 수
    private int weight[][];    //노드들 간의 가중치 저장 변수

    public Graph(int n){
        this.V = n;
        weight = new int[n + 1][n + 1];
    }

    public void input(int i, int j, int w){
        weight[i][j] = w;
        weight[j][i] = w;
    }

    public void dijkstra(int start){
        int[] D = new int[V + 1];          //최단 거리 저장 변수
        boolean[] visited = new boolean[V + 1];     //해당 노드를 방문했는지 체크할 변수

        //시작점부터 각 노드까지의 모든 거리 초기화
        for(int i = 1; i < V + 1; i++)
            D[i] = Integer.MAX_VALUE;

        //시작 노드 값 초기화
        D[start] = 0;
        visited[start] = true;

        //연결 노드 D 갱신
        for(int i = 1; i < V + 1; i++)
            if(!visited[i] && weight[start][i] != 0)      //방문하지 않았고 시작점에서 i까지의 가중치가 존재한다면, 거리 i에 시작점에서 i까지의 가중치 저장
                D[i] = weight[start][i];

        for(int i = 0; i < V - 1; i++) {
            int min = Integer.MAX_VALUE;    //가장 작은 값 기억 변수
            int min_index = -1;     //가장 작은 값의 위치 기억 변수

            //최소값 찾기
            for (int j = 1; j < V + 1; j++)
                if (!visited[i] && D[j] != Integer.MAX_VALUE) {       //방문하지 않았고 거리를 갱신한 노드들 중에서 가장 가까운 거리와 가장 가까운 노드를 구하기
                    if (D[j] < min) {
                        min = D[j];
                        min_index = j;
                    }
                }

            visited[min_index] = true;  //위의 반복문을 통해 도출된 가장 가까운 노드에 방문 표시
            for (int k = 1; k < V + 1; k++)
                if (!visited[k] && weight[min_index][k] != 0)      //방문하지 않았고 min_index와의 가중치가 존재하는 꼭지점이라면 (min_index에서 연결)
                    if (D[k] > D[min_index] + weight[min_index][k]) //지금 그 꼭지점이 가지고 있는 거리 값이 min_index와 가중치를 더한 값보다 크다면 최단거리 갱신
                        D[k] = D[min_index] + weight[min_index][k];
        }

        for(int i = 1; i < V + 1; i++)
            System.out.print(D[i] + " ");
        System.out.println("");
    }
}

public class Shortest_Path{

    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);

        int V = scanner.nextInt();      //정점의 수
        int E = scanner.nextInt();      //간선의 수
        int s = scanner.nextInt();      //출발점 s

        Graph G = new Graph(V);

        for(int i = 0; i < E; i++){
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int c = scanner.nextInt();
        }

        G.dijkstra(s);
    }
}
